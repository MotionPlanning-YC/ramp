!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
A	mobile_base.cpp	/^  double A = 2 * (p0.positions.at(0) - (2*p1.positions.at(0)) + p2.positions.at(0));$/;"	l
A	mobile_base.h	/^  double A, B, C, D;$/;"	m	struct:BezierConstants	access:public
B	mobile_base.cpp	/^  double B = 2 * (p0.positions.at(1) - (2*p1.positions.at(1)) + p2.positions.at(1));$/;"	l
B	mobile_base.h	/^  double A, B, C, D;$/;"	m	struct:BezierConstants	access:public
Bezier	mobile_base.cpp	/^const ramp_msgs::Path MobileBase::Bezier(const ramp_msgs::Path p) {$/;"	f	class:MobileBase	signature:(const ramp_msgs::Path p)
Bezier	mobile_base.h	/^  const ramp_msgs::Path Bezier(const ramp_msgs::Path p);$/;"	p	class:MobileBase	access:public	signature:(const ramp_msgs::Path p)
BezierConstants	mobile_base.h	/^struct BezierConstants {$/;"	s
BezierConstants::A	mobile_base.h	/^  double A, B, C, D;$/;"	m	struct:BezierConstants	access:public
BezierConstants::B	mobile_base.h	/^  double A, B, C, D;$/;"	m	struct:BezierConstants	access:public
BezierConstants::C	mobile_base.h	/^  double A, B, C, D;$/;"	m	struct:BezierConstants	access:public
BezierConstants::D	mobile_base.h	/^  double A, B, C, D;$/;"	m	struct:BezierConstants	access:public
BezierCurve	mobile_base.cpp	/^const std::vector<ramp_msgs::MotionState> MobileBase::BezierCurve(const ramp_msgs::MotionState p0, const ramp_msgs::MotionState p1, const ramp_msgs::MotionState p2) {$/;"	f	class:MobileBase	signature:(const ramp_msgs::MotionState p0, const ramp_msgs::MotionState p1, const ramp_msgs::MotionState p2)
BezierCurve	mobile_base.h	/^  const std::vector<ramp_msgs::MotionState> BezierCurve(const ramp_msgs::MotionState p0, const ramp_msgs::MotionState p1, const ramp_msgs::MotionState p2);$/;"	p	class:MobileBase	access:public	signature:(const ramp_msgs::MotionState p0, const ramp_msgs::MotionState p1, const ramp_msgs::MotionState p2)
BezierPoint	mobile_base.cpp	/^    result.push_back(BezierPoint(u, u_dot, u_dot_dot, p0, p1, p2));$/;"	p	file:	signature:(u, u_dot, u_dot_dot, p0, p1, p2)
BezierPoint	mobile_base.cpp	/^const ramp_msgs::MotionState MobileBase::BezierPoint(const double u, const double u_dot, const double u_dot_dot, const ramp_msgs::MotionState p0, const ramp_msgs::MotionState p1, const ramp_msgs::MotionState p2) {$/;"	f	class:MobileBase	signature:(const double u, const double u_dot, const double u_dot_dot, const ramp_msgs::MotionState p0, const ramp_msgs::MotionState p1, const ramp_msgs::MotionState p2)
BezierPoint	mobile_base.h	/^  const ramp_msgs::MotionState BezierPoint(const double u, const double u_dot, const double u_dot_dot, const ramp_msgs::MotionState p0, const ramp_msgs::MotionState p1, const ramp_msgs::MotionState p2);$/;"	p	class:MobileBase	access:public	signature:(const double u, const double u_dot, const double u_dot_dot, const ramp_msgs::MotionState p0, const ramp_msgs::MotionState p1, const ramp_msgs::MotionState p2)
C	mobile_base.cpp	/^  double C = 2 * (p1.positions.at(0) - p0.positions.at(0));$/;"	l
C	mobile_base.h	/^  double A, B, C, D;$/;"	m	struct:BezierConstants	access:public
CYCLE_TIME_IN_SECONDS	mobile_base.h	15;"	d
D	mobile_base.cpp	/^  double D = 2 * (p1.positions.at(1) - p0.positions.at(1));$/;"	l
D	mobile_base.cpp	/^  std::cout<<"\\nA: "<<A<<" B: "<<B<<" C: "<<C<<" D: "<<D;$/;"	l
D	mobile_base.h	/^  double A, B, C, D;$/;"	m	struct:BezierConstants	access:public
MOBILE_BASE_H	mobile_base.h	2;"	d
MobileBase	mobile_base.cpp	/^MobileBase::MobileBase() {$/;"	f	class:MobileBase	signature:()
MobileBase	mobile_base.h	/^  MobileBase();$/;"	p	class:MobileBase	access:public	signature:()
MobileBase	mobile_base.h	/^class MobileBase {$/;"	c
MobileBase::Bezier	mobile_base.cpp	/^const ramp_msgs::Path MobileBase::Bezier(const ramp_msgs::Path p) {$/;"	f	class:MobileBase	signature:(const ramp_msgs::Path p)
MobileBase::Bezier	mobile_base.h	/^  const ramp_msgs::Path Bezier(const ramp_msgs::Path p);$/;"	p	class:MobileBase	access:public	signature:(const ramp_msgs::Path p)
MobileBase::BezierCurve	mobile_base.cpp	/^const std::vector<ramp_msgs::MotionState> MobileBase::BezierCurve(const ramp_msgs::MotionState p0, const ramp_msgs::MotionState p1, const ramp_msgs::MotionState p2) {$/;"	f	class:MobileBase	signature:(const ramp_msgs::MotionState p0, const ramp_msgs::MotionState p1, const ramp_msgs::MotionState p2)
MobileBase::BezierCurve	mobile_base.h	/^  const std::vector<ramp_msgs::MotionState> BezierCurve(const ramp_msgs::MotionState p0, const ramp_msgs::MotionState p1, const ramp_msgs::MotionState p2);$/;"	p	class:MobileBase	access:public	signature:(const ramp_msgs::MotionState p0, const ramp_msgs::MotionState p1, const ramp_msgs::MotionState p2)
MobileBase::BezierPoint	mobile_base.cpp	/^const ramp_msgs::MotionState MobileBase::BezierPoint(const double u, const double u_dot, const double u_dot_dot, const ramp_msgs::MotionState p0, const ramp_msgs::MotionState p1, const ramp_msgs::MotionState p2) {$/;"	f	class:MobileBase	signature:(const double u, const double u_dot, const double u_dot_dot, const ramp_msgs::MotionState p0, const ramp_msgs::MotionState p1, const ramp_msgs::MotionState p2)
MobileBase::BezierPoint	mobile_base.h	/^  const ramp_msgs::MotionState BezierPoint(const double u, const double u_dot, const double u_dot_dot, const ramp_msgs::MotionState p0, const ramp_msgs::MotionState p1, const ramp_msgs::MotionState p2);$/;"	p	class:MobileBase	access:public	signature:(const double u, const double u_dot, const double u_dot_dot, const ramp_msgs::MotionState p0, const ramp_msgs::MotionState p1, const ramp_msgs::MotionState p2)
MobileBase::MobileBase	mobile_base.cpp	/^MobileBase::MobileBase() {$/;"	f	class:MobileBase	signature:()
MobileBase::MobileBase	mobile_base.h	/^  MobileBase();$/;"	p	class:MobileBase	access:public	signature:()
MobileBase::buildTrajectoryPoint	mobile_base.cpp	/^const trajectory_msgs::JointTrajectoryPoint MobileBase::buildTrajectoryPoint(const RMLPositionInputParameters my_inputParameters) {$/;"	f	class:MobileBase	signature:(const RMLPositionInputParameters my_inputParameters)
MobileBase::buildTrajectoryPoint	mobile_base.cpp	/^const trajectory_msgs::JointTrajectoryPoint MobileBase::buildTrajectoryPoint(const RMLPositionOutputParameters my_outputParameters) {$/;"	f	class:MobileBase	signature:(const RMLPositionOutputParameters my_outputParameters)
MobileBase::buildTrajectoryPoint	mobile_base.h	/^  const trajectory_msgs::JointTrajectoryPoint buildTrajectoryPoint(const RMLPositionInputParameters inputParameters);$/;"	p	class:MobileBase	access:private	signature:(const RMLPositionInputParameters inputParameters)
MobileBase::buildTrajectoryPoint	mobile_base.h	/^  const trajectory_msgs::JointTrajectoryPoint buildTrajectoryPoint(const RMLPositionOutputParameters outputParameters);$/;"	p	class:MobileBase	access:private	signature:(const RMLPositionOutputParameters outputParameters)
MobileBase::calculateConstants	mobile_base.cpp	/^const BezierConstants MobileBase::calculateConstants(const ramp_msgs::MotionState p0, const ramp_msgs::MotionState p1, const ramp_msgs::MotionState p2) const {$/;"	f	class:MobileBase	signature:(const ramp_msgs::MotionState p0, const ramp_msgs::MotionState p1, const ramp_msgs::MotionState p2) const
MobileBase::calculateConstants	mobile_base.h	/^  const BezierConstants calculateConstants(const ramp_msgs::MotionState p0, const ramp_msgs::MotionState p1, const ramp_msgs::MotionState p2) const; $/;"	p	class:MobileBase	access:public	signature:(const ramp_msgs::MotionState p0, const ramp_msgs::MotionState p1, const ramp_msgs::MotionState p2) const
MobileBase::calculateR_min	mobile_base.cpp	/^const double MobileBase::calculateR_min(const double t_min, const double A, const double B, const double C, const double D) const {$/;"	f	class:MobileBase	signature:(const double t_min, const double A, const double B, const double C, const double D) const
MobileBase::calculateR_min	mobile_base.h	/^  const double calculateR_min(const double t_min, const double A, const double B, const double C, const double D) const;$/;"	p	class:MobileBase	access:public	signature:(const double t_min, const double A, const double B, const double C, const double D) const
MobileBase::computeTargetOrientation	mobile_base.cpp	/^double MobileBase::computeTargetOrientation(double initial_x, double initial_y, double target_x, double target_y) {$/;"	f	class:MobileBase	signature:(double initial_x, double initial_y, double target_x, double target_y)
MobileBase::computeTargetOrientation	mobile_base.h	/^  double computeTargetOrientation(double initial_x, double intial_y, double target_x, double target_y);$/;"	p	class:MobileBase	access:private	signature:(double initial_x, double intial_y, double target_x, double target_y)
MobileBase::getSegmentControlPoints	mobile_base.cpp	/^const std::vector<ramp_msgs::MotionState> MobileBase::getSegmentControlPoints(const double lambda, const ramp_msgs::MotionState x0, const ramp_msgs::MotionState x1, const ramp_msgs::MotionState x2) const {$/;"	f	class:MobileBase	signature:(const double lambda, const ramp_msgs::MotionState x0, const ramp_msgs::MotionState x1, const ramp_msgs::MotionState x2) const
MobileBase::getSegmentControlPoints	mobile_base.h	/^  const std::vector<ramp_msgs::MotionState> getSegmentControlPoints(const double lambda, const ramp_msgs::MotionState x0, const ramp_msgs::MotionState x1, const ramp_msgs::MotionState x2) const;$/;"	p	class:MobileBase	access:public	signature:(const double lambda, const ramp_msgs::MotionState x0, const ramp_msgs::MotionState x1, const ramp_msgs::MotionState x2) const
MobileBase::i_kp_	mobile_base.h	/^  uint8_t i_kp_;$/;"	m	class:MobileBase	access:private
MobileBase::initialize	mobile_base.cpp	/^void MobileBase::initialize(const ramp_msgs::TrajectoryRequest::Request req) {$/;"	f	class:MobileBase	signature:(const ramp_msgs::TrajectoryRequest::Request req)
MobileBase::initialize	mobile_base.h	/^  void initialize(const ramp_msgs::TrajectoryRequest::Request req);$/;"	p	class:MobileBase	access:private	signature:(const ramp_msgs::TrajectoryRequest::Request req)
MobileBase::initializeBezier	mobile_base.cpp	/^void MobileBase::initializeBezier() {$/;"	f	class:MobileBase	signature:()
MobileBase::initializeBezier	mobile_base.h	/^  void initializeBezier();$/;"	p	class:MobileBase	access:public	signature:()
MobileBase::isFinalStateReached	mobile_base.cpp	/^bool MobileBase::isFinalStateReached() {$/;"	f	class:MobileBase	signature:()
MobileBase::isFinalStateReached	mobile_base.h	/^  bool isFinalStateReached();$/;"	p	class:MobileBase	access:private	signature:()
MobileBase::path_	mobile_base.h	/^  ramp_msgs::Path path_;$/;"	m	class:MobileBase	access:private
MobileBase::reflexBezier_	mobile_base.h	/^  ReflexxesData reflexBezier_;$/;"	m	class:MobileBase	access:private
MobileBase::reflexPlanar_	mobile_base.h	/^  ReflexxesData reflexPlanar_;$/;"	m	class:MobileBase	access:private
MobileBase::resultValue	mobile_base.h	/^  int resultValue;$/;"	m	class:MobileBase	access:private
MobileBase::setInitialConditions	mobile_base.cpp	/^void MobileBase::setInitialConditions() {$/;"	f	class:MobileBase	signature:()
MobileBase::setInitialConditions	mobile_base.h	/^  void setInitialConditions();$/;"	p	class:MobileBase	access:private	signature:()
MobileBase::setPlanarSelectionVector	mobile_base.cpp	/^void MobileBase::setPlanarSelectionVector(const bool rot) {$/;"	f	class:MobileBase	signature:(const bool rot)
MobileBase::setPlanarSelectionVector	mobile_base.h	/^  void setPlanarSelectionVector(const bool rot);$/;"	p	class:MobileBase	access:private	signature:(const bool rot)
MobileBase::setTarget	mobile_base.cpp	/^void MobileBase::setTarget(const ramp_msgs::MotionState ms, ReflexxesData& reflex) {$/;"	f	class:MobileBase	signature:(const ramp_msgs::MotionState ms, ReflexxesData& reflex)
MobileBase::setTarget	mobile_base.h	/^  void setTarget(const ramp_msgs::MotionState ms, ReflexxesData& reflex);$/;"	p	class:MobileBase	access:private	signature:(const ramp_msgs::MotionState ms, ReflexxesData& reflex)
MobileBase::spinOnce	mobile_base.cpp	/^trajectory_msgs::JointTrajectoryPoint MobileBase::spinOnce() {$/;"	f	class:MobileBase	signature:()
MobileBase::spinOnce	mobile_base.h	/^  trajectory_msgs::JointTrajectoryPoint spinOnce();$/;"	p	class:MobileBase	access:private	signature:()
MobileBase::spinOnceBezier	mobile_base.cpp	/^ramp_msgs::MotionState MobileBase::spinOnceBezier(const ramp_msgs::MotionState x0, const ramp_msgs::MotionState x1, const ramp_msgs::MotionState x2) {$/;"	f	class:MobileBase	signature:(const ramp_msgs::MotionState x0, const ramp_msgs::MotionState x1, const ramp_msgs::MotionState x2)
MobileBase::spinOnceBezier	mobile_base.h	/^  ramp_msgs::MotionState spinOnceBezier(const ramp_msgs::MotionState x0, const ramp_msgs::MotionState x1, const ramp_msgs::MotionState x2);$/;"	p	class:MobileBase	access:private	signature:(const ramp_msgs::MotionState x0, const ramp_msgs::MotionState x1, const ramp_msgs::MotionState x2)
MobileBase::timeCutoff_	mobile_base.h	/^  ros::Duration timeCutoff_;$/;"	m	class:MobileBase	access:private
MobileBase::timeFromStart_	mobile_base.h	/^  ros::Duration timeFromStart_;$/;"	m	class:MobileBase	access:private
MobileBase::trajectoryRequest	mobile_base.cpp	/^bool MobileBase::trajectoryRequest(ramp_msgs::TrajectoryRequest::Request& req, ramp_msgs::TrajectoryRequest::Response& res) {$/;"	f	class:MobileBase	signature:(ramp_msgs::TrajectoryRequest::Request& req, ramp_msgs::TrajectoryRequest::Response& res)
MobileBase::trajectoryRequest	mobile_base.h	/^  bool trajectoryRequest(ramp_msgs::TrajectoryRequest::Request& req,ramp_msgs::TrajectoryRequest::Response& res);$/;"	p	class:MobileBase	access:public	signature:(ramp_msgs::TrajectoryRequest::Request& req,ramp_msgs::TrajectoryRequest::Response& res)
MobileBase::utility_	mobile_base.h	/^  Utility utility_;$/;"	m	class:MobileBase	access:private
MobileBase::~MobileBase	mobile_base.cpp	/^MobileBase::~MobileBase() {$/;"	f	class:MobileBase	signature:()
MobileBase::~MobileBase	mobile_base.h	/^  ~MobileBase();$/;"	p	class:MobileBase	access:public	signature:()
NUMBER_OF_DOFS	mobile_base.h	/^  unsigned int NUMBER_OF_DOFS;$/;"	m	struct:ReflexxesData	access:public
PI	utility.h	16;"	d
R_min	mobile_base.cpp	/^  double R_min                = sqrt( numerator \/ denominator );$/;"	l
R_min	mobile_base.cpp	/^  double R_min = calculateR_min(t_min, A, B, C, D);$/;"	l
R_min	mobile_base.cpp	/^  std::cout<<"\\nR_min: "<<R_min;$/;"	l
ReflexxesData	mobile_base.h	/^struct ReflexxesData {$/;"	s
ReflexxesData::NUMBER_OF_DOFS	mobile_base.h	/^  unsigned int NUMBER_OF_DOFS;$/;"	m	struct:ReflexxesData	access:public
ReflexxesData::flags	mobile_base.h	/^  RMLPositionFlags flags;$/;"	m	struct:ReflexxesData	access:public
ReflexxesData::inputParameters	mobile_base.h	/^  RMLPositionInputParameters *inputParameters;          $/;"	m	struct:ReflexxesData	access:public
ReflexxesData::outputParameters	mobile_base.h	/^  RMLPositionOutputParameters *outputParameters;$/;"	m	struct:ReflexxesData	access:public
ReflexxesData::rml	mobile_base.h	/^  ReflexxesAPI *rml;$/;"	m	struct:ReflexxesData	access:public
UTILITY_H	utility.h	2;"	d
Utility	utility.cpp	/^Utility::Utility() {}$/;"	f	class:Utility	signature:()
Utility	utility.h	/^    Utility();$/;"	p	class:Utility	access:public	signature:()
Utility	utility.h	/^class Utility {$/;"	c
Utility::Utility	utility.cpp	/^Utility::Utility() {}$/;"	f	class:Utility	signature:()
Utility::Utility	utility.h	/^    Utility();$/;"	p	class:Utility	access:public	signature:()
Utility::displaceAngle	utility.cpp	/^const double Utility::displaceAngle(const double a1, double a2) const {$/;"	f	class:Utility	signature:(const double a1, double a2) const
Utility::displaceAngle	utility.h	/^    const double displaceAngle(const double a1, double a2) const;$/;"	p	class:Utility	access:public	signature:(const double a1, double a2) const
Utility::findAngleFromAToB	utility.cpp	/^const double Utility::findAngleFromAToB(const std::vector<double> a, const std::vector<double> b) const {$/;"	f	class:Utility	signature:(const std::vector<double> a, const std::vector<double> b) const
Utility::findAngleFromAToB	utility.cpp	/^const double Utility::findAngleFromAToB(const trajectory_msgs::JointTrajectoryPoint a, const trajectory_msgs::JointTrajectoryPoint b) const {$/;"	f	class:Utility	signature:(const trajectory_msgs::JointTrajectoryPoint a, const trajectory_msgs::JointTrajectoryPoint b) const
Utility::findAngleFromAToB	utility.h	/^    const double findAngleFromAToB(const std::vector<double> a, const std::vector<double> b) const;$/;"	p	class:Utility	access:public	signature:(const std::vector<double> a, const std::vector<double> b) const
Utility::findAngleFromAToB	utility.h	/^    const double findAngleFromAToB(const trajectory_msgs::JointTrajectoryPoint a, const trajectory_msgs::JointTrajectoryPoint b) const;$/;"	p	class:Utility	access:public	signature:(const trajectory_msgs::JointTrajectoryPoint a, const trajectory_msgs::JointTrajectoryPoint b) const
Utility::findDistanceBetweenAngles	utility.cpp	/^const double Utility::findDistanceBetweenAngles(const double a1, const double a2) const {$/;"	f	class:Utility	signature:(const double a1, const double a2) const
Utility::findDistanceBetweenAngles	utility.h	/^    const double findDistanceBetweenAngles(const double a1, const double a2) const;$/;"	p	class:Utility	access:public	signature:(const double a1, const double a2) const
Utility::getEuclideanDist	utility.cpp	/^const double Utility::getEuclideanDist(const std::vector<double> a, const std::vector<double> b) const {$/;"	f	class:Utility	signature:(const std::vector<double> a, const std::vector<double> b) const
Utility::getEuclideanDist	utility.h	/^    const double getEuclideanDist(const std::vector<double> a, std::vector<double> b) const;$/;"	p	class:Utility	access:public	signature:(const std::vector<double> a, std::vector<double> b) const
Utility::getKnotPoint	utility.cpp	/^const ramp_msgs::KnotPoint Utility::getKnotPoint(const ramp_msgs::MotionState ms) const {$/;"	f	class:Utility	signature:(const ramp_msgs::MotionState ms) const
Utility::getKnotPoint	utility.h	/^    const ramp_msgs::KnotPoint getKnotPoint(const ramp_msgs::MotionState ms) const;$/;"	p	class:Utility	access:public	signature:(const ramp_msgs::MotionState ms) const
Utility::getPath	utility.cpp	/^const ramp_msgs::Path Utility::getPath(const std::vector<ramp_msgs::KnotPoint> kps) const {$/;"	f	class:Utility	signature:(const std::vector<ramp_msgs::KnotPoint> kps) const
Utility::getPath	utility.cpp	/^const ramp_msgs::Path Utility::getPath(const std::vector<ramp_msgs::MotionState> mps) const {$/;"	f	class:Utility	signature:(const std::vector<ramp_msgs::MotionState> mps) const
Utility::getPath	utility.h	/^    const ramp_msgs::Path getPath(const std::vector<ramp_msgs::KnotPoint>   kps) const;$/;"	p	class:Utility	access:public	signature:(const std::vector<ramp_msgs::KnotPoint> kps) const
Utility::getPath	utility.h	/^    const ramp_msgs::Path getPath(const std::vector<ramp_msgs::MotionState> mps) const;$/;"	p	class:Utility	access:public	signature:(const std::vector<ramp_msgs::MotionState> mps) const
Utility::positionDistance	utility.cpp	/^const double Utility::positionDistance(const std::vector<double> a, const std::vector<double> b) const {$/;"	f	class:Utility	signature:(const std::vector<double> a, const std::vector<double> b) const
Utility::positionDistance	utility.h	/^    const double positionDistance(const std::vector<double> a, const std::vector<double> b) const;$/;"	p	class:Utility	access:public	signature:(const std::vector<double> a, const std::vector<double> b) const
Utility::toString	utility.cpp	/^const std::string Utility::toString(const ramp_msgs::KnotPoint kp) const {$/;"	f	class:Utility	signature:(const ramp_msgs::KnotPoint kp) const
Utility::toString	utility.cpp	/^const std::string Utility::toString(const ramp_msgs::MotionState mp) const {$/;"	f	class:Utility	signature:(const ramp_msgs::MotionState mp) const
Utility::toString	utility.cpp	/^const std::string Utility::toString(const ramp_msgs::Path path) const {$/;"	f	class:Utility	signature:(const ramp_msgs::Path path) const
Utility::toString	utility.cpp	/^const std::string Utility::toString(const ramp_msgs::Trajectory traj) const {$/;"	f	class:Utility	signature:(const ramp_msgs::Trajectory traj) const
Utility::toString	utility.cpp	/^const std::string Utility::toString(const trajectory_msgs::JointTrajectoryPoint p) const {$/;"	f	class:Utility	signature:(const trajectory_msgs::JointTrajectoryPoint p) const
Utility::toString	utility.h	/^    const std::string toString(const ramp_msgs::KnotPoint kp) const;$/;"	p	class:Utility	access:public	signature:(const ramp_msgs::KnotPoint kp) const
Utility::toString	utility.h	/^    const std::string toString(const ramp_msgs::MotionState mp) const;$/;"	p	class:Utility	access:public	signature:(const ramp_msgs::MotionState mp) const
Utility::toString	utility.h	/^    const std::string toString(const ramp_msgs::Path path) const;$/;"	p	class:Utility	access:public	signature:(const ramp_msgs::Path path) const
Utility::toString	utility.h	/^    const std::string toString(const ramp_msgs::Trajectory traj) const;$/;"	p	class:Utility	access:public	signature:(const ramp_msgs::Trajectory traj) const
Utility::toString	utility.h	/^    const std::string toString(const trajectory_msgs::JointTrajectoryPoint p) const;$/;"	p	class:Utility	access:public	signature:(const trajectory_msgs::JointTrajectoryPoint p) const
angle	mobile_base.cpp	/^  double angle = utility_.findAngleFromAToB(current_position, target_position);$/;"	l
at	utility.cpp	/^    result<<", "<<p.accelerations.at(k);$/;"	p	file:	signature:(k)
at	utility.cpp	/^    result<<", "<<p.positions.at(k);$/;"	p	file:	signature:(k)
at	utility.cpp	/^    result<<", "<<p.velocities.at(k);$/;"	p	file:	signature:(k)
at	utility.cpp	/^    result<<mp.accelerations.at(i)<<" ";$/;"	p	file:	signature:(i)
at	utility.cpp	/^    result<<mp.jerks.at(i)<<" ";$/;"	p	file:	signature:(i)
at	utility.cpp	/^    result<<mp.positions.at(i)<<" ";$/;"	p	file:	signature:(i)
at	utility.cpp	/^    result<<mp.velocities.at(i)<<" ";$/;"	p	file:	signature:(i)
bc	mobile_base.cpp	/^  BezierConstants bc = calculateConstants(p0, p1, p2);$/;"	l
bc	mobile_base.cpp	/^  BezierConstants bc = calculateConstants(x0, x1, x2);$/;"	l
buildTrajectoryPoint	mobile_base.cpp	/^const trajectory_msgs::JointTrajectoryPoint MobileBase::buildTrajectoryPoint(const RMLPositionInputParameters my_inputParameters) {$/;"	f	class:MobileBase	signature:(const RMLPositionInputParameters my_inputParameters)
buildTrajectoryPoint	mobile_base.cpp	/^const trajectory_msgs::JointTrajectoryPoint MobileBase::buildTrajectoryPoint(const RMLPositionOutputParameters my_outputParameters) {$/;"	f	class:MobileBase	signature:(const RMLPositionOutputParameters my_outputParameters)
buildTrajectoryPoint	mobile_base.h	/^  const trajectory_msgs::JointTrajectoryPoint buildTrajectoryPoint(const RMLPositionInputParameters inputParameters);$/;"	p	class:MobileBase	access:private	signature:(const RMLPositionInputParameters inputParameters)
buildTrajectoryPoint	mobile_base.h	/^  const trajectory_msgs::JointTrajectoryPoint buildTrajectoryPoint(const RMLPositionOutputParameters outputParameters);$/;"	p	class:MobileBase	access:private	signature:(const RMLPositionOutputParameters outputParameters)
c	utility.cpp	/^  std::vector<double> c;$/;"	l
calculateConstants	mobile_base.cpp	/^const BezierConstants MobileBase::calculateConstants(const ramp_msgs::MotionState p0, const ramp_msgs::MotionState p1, const ramp_msgs::MotionState p2) const {$/;"	f	class:MobileBase	signature:(const ramp_msgs::MotionState p0, const ramp_msgs::MotionState p1, const ramp_msgs::MotionState p2) const
calculateConstants	mobile_base.h	/^  const BezierConstants calculateConstants(const ramp_msgs::MotionState p0, const ramp_msgs::MotionState p1, const ramp_msgs::MotionState p2) const; $/;"	p	class:MobileBase	access:public	signature:(const ramp_msgs::MotionState p0, const ramp_msgs::MotionState p1, const ramp_msgs::MotionState p2) const
calculateR_min	mobile_base.cpp	/^const double MobileBase::calculateR_min(const double t_min, const double A, const double B, const double C, const double D) const {$/;"	f	class:MobileBase	signature:(const double t_min, const double A, const double B, const double C, const double D) const
calculateR_min	mobile_base.h	/^  const double calculateR_min(const double t_min, const double A, const double B, const double C, const double D) const;$/;"	p	class:MobileBase	access:public	signature:(const double t_min, const double A, const double B, const double C, const double D) const
computeTargetOrientation	mobile_base.cpp	/^double MobileBase::computeTargetOrientation(double initial_x, double initial_y, double target_x, double target_y) {$/;"	f	class:MobileBase	signature:(double initial_x, double initial_y, double target_x, double target_y)
computeTargetOrientation	mobile_base.h	/^  double computeTargetOrientation(double initial_x, double intial_y, double target_x, double target_y);$/;"	p	class:MobileBase	access:private	signature:(double initial_x, double intial_y, double target_x, double target_y)
control_points	mobile_base.cpp	/^    std::vector<ramp_msgs::MotionState> control_points = $/;"	l
cout	main.cpp	/^  std::cout<<"\\nPublished Population";$/;"	m	class:std	file:
cout	main.cpp	/^  std::cout<<"\\nWaiting for requests...\\n";$/;"	m	class:std	file:
cout	mobile_base.cpp	/^      std::cout<<"\\nin while\\n";$/;"	m	class:std	file:
cout	mobile_base.cpp	/^    std::cout<<"\\nTarget set\\n";$/;"	m	class:std	file:
cout	mobile_base.cpp	/^  std::cout<<"\\n"<<((0.33\/R_min)<PI\/4);$/;"	p	class:std	file:	signature:(0.33/R_min)<PI/4
cout	mobile_base.cpp	/^  std::cout<<"\\nDone initializing\\n";$/;"	m	class:std	file:
cout	mobile_base.cpp	/^  std::cout<<"\\nIn Bezier\\n";$/;"	m	class:std	file:
cout	mobile_base.cpp	/^  std::cout<<"\\nIn getSegmentControlPoints\\n";$/;"	m	class:std	file:
cout	mobile_base.cpp	/^  std::cout<<"\\nIn spinOnceBezier\\n";$/;"	m	class:std	file:
cout	mobile_base.cpp	/^  std::cout<<"\\nLeaving getSegmentControlPoints\\n";$/;"	m	class:std	file:
cout	mobile_base.cpp	/^  std::cout<<"\\nLeaving spinOnceBezier\\n";$/;"	m	class:std	file:
current_position	mobile_base.cpp	/^  std::vector<double> current_position;$/;"	l
d	utility.cpp	/^  std::vector<double> d;$/;"	l
d_x	utility.cpp	/^  double d_x = b.at(0) - a.at(0);$/;"	l
d_y	utility.cpp	/^  double d_y = b.at(1) - a.at(1);$/;"	l
denominator	mobile_base.cpp	/^  double denominator          = pow((B*C) - (A*D), 2);$/;"	l
difference	utility.cpp	/^  double difference = a2 - a1;$/;"	l
displaceAngle	utility.cpp	/^const double Utility::displaceAngle(const double a1, double a2) const {$/;"	f	class:Utility	signature:(const double a1, double a2) const
displaceAngle	utility.h	/^    const double displaceAngle(const double a1, double a2) const;$/;"	p	class:Utility	access:public	signature:(const double a1, double a2) const
euc_dist	utility.cpp	/^  double euc_dist = sqrt( pow(d_x,2) + pow(d_y,2) );$/;"	l
findAngleFromAToB	utility.cpp	/^const double Utility::findAngleFromAToB(const std::vector<double> a, const std::vector<double> b) const {$/;"	f	class:Utility	signature:(const std::vector<double> a, const std::vector<double> b) const
findAngleFromAToB	utility.cpp	/^const double Utility::findAngleFromAToB(const trajectory_msgs::JointTrajectoryPoint a, const trajectory_msgs::JointTrajectoryPoint b) const {$/;"	f	class:Utility	signature:(const trajectory_msgs::JointTrajectoryPoint a, const trajectory_msgs::JointTrajectoryPoint b) const
findAngleFromAToB	utility.h	/^    const double findAngleFromAToB(const std::vector<double> a, const std::vector<double> b) const;$/;"	p	class:Utility	access:public	signature:(const std::vector<double> a, const std::vector<double> b) const
findAngleFromAToB	utility.h	/^    const double findAngleFromAToB(const trajectory_msgs::JointTrajectoryPoint a, const trajectory_msgs::JointTrajectoryPoint b) const;$/;"	p	class:Utility	access:public	signature:(const trajectory_msgs::JointTrajectoryPoint a, const trajectory_msgs::JointTrajectoryPoint b) const
findDistanceBetweenAngles	utility.cpp	/^const double Utility::findDistanceBetweenAngles(const double a1, const double a2) const {$/;"	f	class:Utility	signature:(const double a1, const double a2) const
findDistanceBetweenAngles	utility.h	/^    const double findDistanceBetweenAngles(const double a1, const double a2) const;$/;"	p	class:Utility	access:public	signature:(const double a1, const double a2) const
flags	mobile_base.h	/^  RMLPositionFlags flags;$/;"	m	struct:ReflexxesData	access:public
getEuclideanDist	utility.cpp	/^const double Utility::getEuclideanDist(const std::vector<double> a, const std::vector<double> b) const {$/;"	f	class:Utility	signature:(const std::vector<double> a, const std::vector<double> b) const
getEuclideanDist	utility.h	/^    const double getEuclideanDist(const std::vector<double> a, std::vector<double> b) const;$/;"	p	class:Utility	access:public	signature:(const std::vector<double> a, std::vector<double> b) const
getKnotPoint	utility.cpp	/^const ramp_msgs::KnotPoint Utility::getKnotPoint(const ramp_msgs::MotionState ms) const {$/;"	f	class:Utility	signature:(const ramp_msgs::MotionState ms) const
getKnotPoint	utility.h	/^    const ramp_msgs::KnotPoint getKnotPoint(const ramp_msgs::MotionState ms) const;$/;"	p	class:Utility	access:public	signature:(const ramp_msgs::MotionState ms) const
getPath	utility.cpp	/^const ramp_msgs::Path Utility::getPath(const std::vector<ramp_msgs::KnotPoint> kps) const {$/;"	f	class:Utility	signature:(const std::vector<ramp_msgs::KnotPoint> kps) const
getPath	utility.cpp	/^const ramp_msgs::Path Utility::getPath(const std::vector<ramp_msgs::MotionState> mps) const {$/;"	f	class:Utility	signature:(const std::vector<ramp_msgs::MotionState> mps) const
getPath	utility.h	/^    const ramp_msgs::Path getPath(const std::vector<ramp_msgs::KnotPoint>   kps) const;$/;"	p	class:Utility	access:public	signature:(const std::vector<ramp_msgs::KnotPoint> kps) const
getPath	utility.h	/^    const ramp_msgs::Path getPath(const std::vector<ramp_msgs::MotionState> mps) const;$/;"	p	class:Utility	access:public	signature:(const std::vector<ramp_msgs::MotionState> mps) const
getSegmentControlPoints	mobile_base.cpp	/^const std::vector<ramp_msgs::MotionState> MobileBase::getSegmentControlPoints(const double lambda, const ramp_msgs::MotionState x0, const ramp_msgs::MotionState x1, const ramp_msgs::MotionState x2) const {$/;"	f	class:MobileBase	signature:(const double lambda, const ramp_msgs::MotionState x0, const ramp_msgs::MotionState x1, const ramp_msgs::MotionState x2) const
getSegmentControlPoints	mobile_base.h	/^  const std::vector<ramp_msgs::MotionState> getSegmentControlPoints(const double lambda, const ramp_msgs::MotionState x0, const ramp_msgs::MotionState x1, const ramp_msgs::MotionState x2) const;$/;"	p	class:MobileBase	access:public	signature:(const double lambda, const ramp_msgs::MotionState x0, const ramp_msgs::MotionState x1, const ramp_msgs::MotionState x2) const
i	mobile_base.cpp	/^    std::cout<<"\\ni: "<<i<<"\\n";$/;"	l
i	utility.cpp	/^    result<<"\\n   "<<i<<":";$/;"	l
i	utility.cpp	/^    result<<"\\n\\n   Point "<<i<<":";$/;"	l
i_kp_	mobile_base.h	/^  uint8_t i_kp_;$/;"	m	class:MobileBase	access:private
index	utility.cpp	/^    unsigned int index = traj.index_knot_points.at(i);$/;"	l
init	main.cpp	/^  ros::init(argc, argv, "reflexxes");$/;"	p	class:ros	file:	signature:(argc, argv, Ó)
initialize	mobile_base.cpp	/^void MobileBase::initialize(const ramp_msgs::TrajectoryRequest::Request req) {$/;"	f	class:MobileBase	signature:(const ramp_msgs::TrajectoryRequest::Request req)
initialize	mobile_base.h	/^  void initialize(const ramp_msgs::TrajectoryRequest::Request req);$/;"	p	class:MobileBase	access:private	signature:(const ramp_msgs::TrajectoryRequest::Request req)
initializeBezier	mobile_base.cpp	/^void MobileBase::initializeBezier() {$/;"	f	class:MobileBase	signature:()
initializeBezier	mobile_base.h	/^  void initializeBezier();$/;"	p	class:MobileBase	access:public	signature:()
inputParameters	mobile_base.h	/^  RMLPositionInputParameters *inputParameters;          $/;"	m	struct:ReflexxesData	access:public
isFinalStateReached	mobile_base.cpp	/^bool MobileBase::isFinalStateReached() {$/;"	f	class:MobileBase	signature:()
isFinalStateReached	mobile_base.h	/^  bool isFinalStateReached();$/;"	p	class:MobileBase	access:private	signature:()
kp	utility.cpp	/^    ramp_msgs::KnotPoint kp;$/;"	l
kp0	main.cpp	/^  ramp_msgs::KnotPoint kp0;$/;"	l
kp1	main.cpp	/^  ramp_msgs::KnotPoint kp1;$/;"	l
kp2	main.cpp	/^  ramp_msgs::KnotPoint kp2;$/;"	l
kp3	main.cpp	/^  ramp_msgs::KnotPoint kp3;$/;"	l
lambda	mobile_base.cpp	/^  double lambda = 0.5;$/;"	l
main	main.cpp	/^int main(int argc, char** argv) {$/;"	f	signature:(int argc, char** argv)
mobileBase	main.cpp	/^  MobileBase mobileBase;$/;"	l
ms	mobile_base.cpp	/^      ramp_msgs::MotionState ms = spinOnceBezier( control_points.at(0), $/;"	l
mu	mobile_base.cpp	/^  double mu = 1-u;$/;"	l
mu2	mobile_base.cpp	/^  double mu2 = mu * mu;$/;"	l
n	main.cpp	/^  ros::NodeHandle n;$/;"	l
numerator	mobile_base.cpp	/^  double numerator            = pow(numerator_term_one + numerator_term_two + numerator_term_three, 3); $/;"	l
numerator_term_one	mobile_base.cpp	/^  double numerator_term_one   = ((A*A) + (B*B)) * (t_min*t_min);$/;"	l
numerator_term_three	mobile_base.cpp	/^  double numerator_term_three = (C*C) + (D*D);$/;"	l
numerator_term_two	mobile_base.cpp	/^  double numerator_term_two   = 2 * ((A*C)+(B*D)) * t_min;$/;"	l
outputParameters	mobile_base.h	/^  RMLPositionOutputParameters *outputParameters;$/;"	m	struct:ReflexxesData	access:public
p	main.cpp	/^  ramp_msgs::Path p;$/;"	l
p	mobile_base.cpp	/^      double p = computeTargetOrientation(reflexPlanar_.inputParameters->CurrentPositionVector->VecData[0],$/;"	l
p	utility.cpp	/^    trajectory_msgs::JointTrajectoryPoint p = traj.trajectory.points.at(i);$/;"	l
p	utility.cpp	/^    trajectory_msgs::JointTrajectoryPoint p = traj.trajectory.points.at(index);$/;"	l
p0	main.cpp	/^  ramp_msgs::MotionState p0, p1, p2, p3;$/;"	l
p1	main.cpp	/^  ramp_msgs::MotionState p0, p1, p2, p3;$/;"	l
p2	main.cpp	/^  ramp_msgs::MotionState p0, p1, p2, p3;$/;"	l
p3	main.cpp	/^  ramp_msgs::MotionState p0, p1, p2, p3;$/;"	l
p_bezier	main.cpp	/^  ramp_msgs::Path p_bezier = mobileBase.Bezier(p);$/;"	l
path_	mobile_base.h	/^  ramp_msgs::Path path_;$/;"	m	class:MobileBase	access:private
point	mobile_base.cpp	/^  trajectory_msgs::JointTrajectoryPoint point = buildTrajectoryPoint(*reflexPlanar_.outputParameters);$/;"	l
point	mobile_base.cpp	/^  trajectory_msgs::JointTrajectoryPoint point;$/;"	l
positionDistance	utility.cpp	/^const double Utility::positionDistance(const std::vector<double> a, const std::vector<double> b) const {$/;"	f	class:Utility	signature:(const std::vector<double> a, const std::vector<double> b) const
positionDistance	utility.h	/^    const double positionDistance(const std::vector<double> a, const std::vector<double> b) const;$/;"	p	class:Utility	access:public	signature:(const std::vector<double> a, const std::vector<double> b) const
positions	mobile_base.cpp	/^  x1_next.positions.push_back( (1-lambda)*x1.positions.at(0) + lambda*x2.positions.at(0) );$/;"	p	file:	signature:(1-lambda)*x1.positions.at(0) + lambda*x2.positions.at(0) 
positions	mobile_base.cpp	/^  x1_next.positions.push_back( (1-lambda)*x1.positions.at(1) + lambda*x2.positions.at(1) );$/;"	p	file:	signature:(1-lambda)*x1.positions.at(1) + lambda*x2.positions.at(1) 
positions	mobile_base.cpp	/^  x1_prev.positions.push_back( (1-lambda)*x0.positions.at(0) + lambda*x1.positions.at(0) );$/;"	p	file:	signature:(1-lambda)*x0.positions.at(0) + lambda*x1.positions.at(0) 
positions	mobile_base.cpp	/^  x1_prev.positions.push_back( (1-lambda)*x0.positions.at(1) + lambda*x1.positions.at(1) );$/;"	p	file:	signature:(1-lambda)*x0.positions.at(1) + lambda*x1.positions.at(1) 
push_back	main.cpp	/^  p.points.push_back(kp0);$/;"	p	file:	signature:(kp0)
push_back	main.cpp	/^  p.points.push_back(kp1);$/;"	p	file:	signature:(kp1)
push_back	main.cpp	/^  p.points.push_back(kp2);$/;"	p	file:	signature:(kp2)
push_back	mobile_base.cpp	/^      point.accelerations.push_back(my_inputParameters.CurrentAccelerationVector->VecData[i]);$/;"	p	file:	signature:(my_inputParameters.CurrentAccelerationVector->VecData[i])
push_back	mobile_base.cpp	/^      point.accelerations.push_back(my_outputParameters.NewAccelerationVector->VecData[i]);$/;"	p	file:	signature:(my_outputParameters.NewAccelerationVector->VecData[i])
push_back	mobile_base.cpp	/^      point.accelerations.push_back(reflexPlanar_.inputParameters->CurrentAccelerationVector->VecData[i]);$/;"	p	file:	signature:(reflexPlanar_.inputParameters->CurrentAccelerationVector->VecData[i])
push_back	mobile_base.cpp	/^      point.positions.push_back(my_inputParameters.CurrentPositionVector->VecData[i]);$/;"	p	file:	signature:(my_inputParameters.CurrentPositionVector->VecData[i])
push_back	mobile_base.cpp	/^      point.positions.push_back(my_outputParameters.NewPositionVector->VecData[i]);$/;"	p	file:	signature:(my_outputParameters.NewPositionVector->VecData[i])
push_back	mobile_base.cpp	/^      point.positions.push_back(p);$/;"	p	file:	signature:(p)
push_back	mobile_base.cpp	/^      point.positions.push_back(reflexPlanar_.inputParameters->CurrentPositionVector->VecData[i]);$/;"	p	file:	signature:(reflexPlanar_.inputParameters->CurrentPositionVector->VecData[i])
push_back	mobile_base.cpp	/^      point.velocities.push_back(my_inputParameters.CurrentVelocityVector->VecData[i]);$/;"	p	file:	signature:(my_inputParameters.CurrentVelocityVector->VecData[i])
push_back	mobile_base.cpp	/^      point.velocities.push_back(my_outputParameters.NewVelocityVector->VecData[i]);$/;"	p	file:	signature:(my_outputParameters.NewVelocityVector->VecData[i])
push_back	mobile_base.cpp	/^      point.velocities.push_back(reflexPlanar_.inputParameters->CurrentVelocityVector->VecData[i]);$/;"	p	file:	signature:(reflexPlanar_.inputParameters->CurrentVelocityVector->VecData[i])
push_back	mobile_base.cpp	/^      res.trajectory.trajectory.points.push_back(buildTrajectoryPoint(*reflexPlanar_.inputParameters));$/;"	p	file:	signature:(buildTrajectoryPoint(reflexPlanar_.inputParameters))
push_back	mobile_base.cpp	/^      result.points.push_back(utility_.getKnotPoint(ms));$/;"	p	file:	signature:(utility_.getKnotPoint(ms))
push_back	mobile_base.cpp	/^    res.trajectory.index_knot_points.push_back(res.trajectory.trajectory.points.size() - 1);$/;"	p	file:	signature:(res.trajectory.trajectory.points.size() - 1)
push_back	mobile_base.cpp	/^  current_position.push_back(initial_x);$/;"	p	file:	signature:(initial_x)
push_back	mobile_base.cpp	/^  current_position.push_back(initial_y);$/;"	p	file:	signature:(initial_y)
push_back	mobile_base.cpp	/^  result.accelerations.push_back(x_dot_dot);$/;"	p	file:	signature:(x_dot_dot)
push_back	mobile_base.cpp	/^  result.accelerations.push_back(y_dot_dot);$/;"	p	file:	signature:(y_dot_dot)
push_back	mobile_base.cpp	/^  result.points.push_back(p.points.at(0));$/;"	p	file:	signature:(p.points.at(0))
push_back	mobile_base.cpp	/^  result.points.push_back(p.points.at(p.points.size()-1));$/;"	p	file:	signature:(p.points.at(p.points.size()-1))
push_back	mobile_base.cpp	/^  result.positions.push_back(x);$/;"	p	file:	signature:(x)
push_back	mobile_base.cpp	/^  result.positions.push_back(y);$/;"	p	file:	signature:(y)
push_back	mobile_base.cpp	/^  result.push_back(x1_next);$/;"	p	file:	signature:(x1_next)
push_back	mobile_base.cpp	/^  result.push_back(x1_prev);$/;"	p	file:	signature:(x1_prev)
push_back	mobile_base.cpp	/^  result.velocities.push_back(x_dot);$/;"	p	file:	signature:(x_dot)
push_back	mobile_base.cpp	/^  result.velocities.push_back(y_dot);$/;"	p	file:	signature:(y_dot)
push_back	mobile_base.cpp	/^  target_position.push_back(target_x);$/;"	p	file:	signature:(target_x)
push_back	mobile_base.cpp	/^  target_position.push_back(target_y);$/;"	p	file:	signature:(target_y)
push_back	mobile_base.cpp	/^  x1_prev.velocities.push_back(x_dot);$/;"	p	file:	signature:(x_dot)
push_back	mobile_base.cpp	/^  x1_prev.velocities.push_back(y_dot);$/;"	p	file:	signature:(y_dot)
push_back	utility.cpp	/^    c.push_back(a.positions.at(i));$/;"	p	file:	signature:(a.positions.at(i))
push_back	utility.cpp	/^    d.push_back(b.positions.at(i));$/;"	p	file:	signature:(b.positions.at(i))
push_back	utility.cpp	/^    result.points.push_back(kp);$/;"	p	file:	signature:(kp)
push_back	utility.cpp	/^    result.points.push_back(kps.at(i));$/;"	p	file:	signature:(kps.at(i))
reflexBezier_	mobile_base.h	/^  ReflexxesData reflexBezier_;$/;"	m	class:MobileBase	access:private
reflexPlanar_	mobile_base.h	/^  ReflexxesData reflexPlanar_;$/;"	m	class:MobileBase	access:private
result	mobile_base.cpp	/^  BezierConstants result;$/;"	l
result	mobile_base.cpp	/^  ramp_msgs::MotionState result;$/;"	l
result	mobile_base.cpp	/^  ramp_msgs::Path result;$/;"	l
result	mobile_base.cpp	/^  std::vector<ramp_msgs::MotionState> result;$/;"	l
result	utility.cpp	/^  double result;$/;"	l
result	utility.cpp	/^  double result=0;$/;"	l
result	utility.cpp	/^  ramp_msgs::KnotPoint result;$/;"	l
result	utility.cpp	/^  ramp_msgs::Path result;$/;"	l
result	utility.cpp	/^  std::ostringstream result;$/;"	l
resultValue	mobile_base.h	/^  int resultValue;$/;"	m	class:MobileBase	access:private
rml	mobile_base.h	/^  ReflexxesAPI *rml;$/;"	m	struct:ReflexxesData	access:public
ros::init	main.cpp	/^  ros::init(argc, argv, "reflexxes");$/;"	p	class:ros	file:	signature:(argc, argv, Ó)
ros::spin	main.cpp	/^  ros::spin();$/;"	p	class:ros	file:	signature:()
service	main.cpp	/^  ros::ServiceServer service = n.advertiseService("trajectory_generator", &MobileBase::trajectoryRequest, &mobileBase);$/;"	l
setInitialConditions	mobile_base.cpp	/^void MobileBase::setInitialConditions() {$/;"	f	class:MobileBase	signature:()
setInitialConditions	mobile_base.h	/^  void setInitialConditions();$/;"	p	class:MobileBase	access:private	signature:()
setPlanarSelectionVector	mobile_base.cpp	/^void MobileBase::setPlanarSelectionVector(const bool rot) {$/;"	f	class:MobileBase	signature:(const bool rot)
setPlanarSelectionVector	mobile_base.h	/^  void setPlanarSelectionVector(const bool rot);$/;"	p	class:MobileBase	access:private	signature:(const bool rot)
setTarget	mobile_base.cpp	/^void MobileBase::setTarget(const ramp_msgs::MotionState ms, ReflexxesData& reflex) {$/;"	f	class:MobileBase	signature:(const ramp_msgs::MotionState ms, ReflexxesData& reflex)
setTarget	mobile_base.h	/^  void setTarget(const ramp_msgs::MotionState ms, ReflexxesData& reflex);$/;"	p	class:MobileBase	access:private	signature:(const ramp_msgs::MotionState ms, ReflexxesData& reflex)
spin	main.cpp	/^  ros::spin();$/;"	p	class:ros	file:	signature:()
spinOnce	mobile_base.cpp	/^      res.trajectory.trajectory.points.push_back(spinOnce());$/;"	p	file:	signature:()
spinOnce	mobile_base.cpp	/^trajectory_msgs::JointTrajectoryPoint MobileBase::spinOnce() {$/;"	f	class:MobileBase	signature:()
spinOnce	mobile_base.h	/^  trajectory_msgs::JointTrajectoryPoint spinOnce();$/;"	p	class:MobileBase	access:private	signature:()
spinOnceBezier	mobile_base.cpp	/^ramp_msgs::MotionState MobileBase::spinOnceBezier(const ramp_msgs::MotionState x0, const ramp_msgs::MotionState x1, const ramp_msgs::MotionState x2) {$/;"	f	class:MobileBase	signature:(const ramp_msgs::MotionState x0, const ramp_msgs::MotionState x1, const ramp_msgs::MotionState x2)
spinOnceBezier	mobile_base.h	/^  ramp_msgs::MotionState spinOnceBezier(const ramp_msgs::MotionState x0, const ramp_msgs::MotionState x1, const ramp_msgs::MotionState x2);$/;"	p	class:MobileBase	access:private	signature:(const ramp_msgs::MotionState x0, const ramp_msgs::MotionState x1, const ramp_msgs::MotionState x2)
std::cout	main.cpp	/^  std::cout<<"\\nPublished Population";$/;"	m	class:std	file:
std::cout	main.cpp	/^  std::cout<<"\\nWaiting for requests...\\n";$/;"	m	class:std	file:
std::cout	mobile_base.cpp	/^      std::cout<<"\\nin while\\n";$/;"	m	class:std	file:
std::cout	mobile_base.cpp	/^    std::cout<<"\\nTarget set\\n";$/;"	m	class:std	file:
std::cout	mobile_base.cpp	/^  std::cout<<"\\n"<<((0.33\/R_min)<PI\/4);$/;"	p	class:std	file:	signature:(0.33/R_min)<PI/4
std::cout	mobile_base.cpp	/^  std::cout<<"\\nDone initializing\\n";$/;"	m	class:std	file:
std::cout	mobile_base.cpp	/^  std::cout<<"\\nIn Bezier\\n";$/;"	m	class:std	file:
std::cout	mobile_base.cpp	/^  std::cout<<"\\nIn getSegmentControlPoints\\n";$/;"	m	class:std	file:
std::cout	mobile_base.cpp	/^  std::cout<<"\\nIn spinOnceBezier\\n";$/;"	m	class:std	file:
std::cout	mobile_base.cpp	/^  std::cout<<"\\nLeaving getSegmentControlPoints\\n";$/;"	m	class:std	file:
std::cout	mobile_base.cpp	/^  std::cout<<"\\nLeaving spinOnceBezier\\n";$/;"	m	class:std	file:
t_min	mobile_base.cpp	/^  double t_min = -((A*C) + (B*D)) \/ ((A*A) + (B*B));$/;"	l
t_min	mobile_base.cpp	/^  std::cout<<"\\nt_min: "<<t_min;$/;"	l
target_position	mobile_base.cpp	/^  std::vector<double> target_position;$/;"	l
timeCutoff_	mobile_base.h	/^  ros::Duration timeCutoff_;$/;"	m	class:MobileBase	access:private
timeFromStart_	mobile_base.h	/^  ros::Duration timeFromStart_;$/;"	m	class:MobileBase	access:private
toString	main.cpp	/^  std::cout<<"\\nPath after Bezier: "<<u.toString(p_bezier)<<"\\n";$/;"	p	file:	signature:(p_bezier)
toString	main.cpp	/^  std::cout<<"\\nPath before Bezier: "<<u.toString(p)<<"\\n";$/;"	p	file:	signature:(p)
toString	mobile_base.cpp	/^    std::cout<<"\\ncontrol_points[0]: "<<utility_.toString(control_points.at(0))<<"\\n";$/;"	p	file:	signature:(control_points.at(0))
toString	mobile_base.cpp	/^    std::cout<<"\\ncontrol_points[1]: "<<utility_.toString(control_points.at(1))<<"\\n";$/;"	p	file:	signature:(control_points.at(1))
toString	utility.cpp	/^    result<<"\\n       "<<toString(p);$/;"	p	file:	signature:(p)
toString	utility.cpp	/^    result<<"\\n "<<i<<": "<<toString(path.points.at(i));$/;"	p	file:	signature:(path.points.at(i))
toString	utility.cpp	/^    result<<"\\n"<<toString(p);$/;"	p	file:	signature:(p)
toString	utility.cpp	/^  result<<"\\nMotion State: "<<toString(kp.motionState);$/;"	p	file:	signature:(kp.motionState)
toString	utility.cpp	/^const std::string Utility::toString(const ramp_msgs::KnotPoint kp) const {$/;"	f	class:Utility	signature:(const ramp_msgs::KnotPoint kp) const
toString	utility.cpp	/^const std::string Utility::toString(const ramp_msgs::MotionState mp) const {$/;"	f	class:Utility	signature:(const ramp_msgs::MotionState mp) const
toString	utility.cpp	/^const std::string Utility::toString(const ramp_msgs::Path path) const {$/;"	f	class:Utility	signature:(const ramp_msgs::Path path) const
toString	utility.cpp	/^const std::string Utility::toString(const ramp_msgs::Trajectory traj) const {$/;"	f	class:Utility	signature:(const ramp_msgs::Trajectory traj) const
toString	utility.cpp	/^const std::string Utility::toString(const trajectory_msgs::JointTrajectoryPoint p) const {$/;"	f	class:Utility	signature:(const trajectory_msgs::JointTrajectoryPoint p) const
toString	utility.h	/^    const std::string toString(const ramp_msgs::KnotPoint kp) const;$/;"	p	class:Utility	access:public	signature:(const ramp_msgs::KnotPoint kp) const
toString	utility.h	/^    const std::string toString(const ramp_msgs::MotionState mp) const;$/;"	p	class:Utility	access:public	signature:(const ramp_msgs::MotionState mp) const
toString	utility.h	/^    const std::string toString(const ramp_msgs::Path path) const;$/;"	p	class:Utility	access:public	signature:(const ramp_msgs::Path path) const
toString	utility.h	/^    const std::string toString(const ramp_msgs::Trajectory traj) const;$/;"	p	class:Utility	access:public	signature:(const ramp_msgs::Trajectory traj) const
toString	utility.h	/^    const std::string toString(const trajectory_msgs::JointTrajectoryPoint p) const;$/;"	p	class:Utility	access:public	signature:(const trajectory_msgs::JointTrajectoryPoint p) const
trajectoryRequest	mobile_base.cpp	/^bool MobileBase::trajectoryRequest(ramp_msgs::TrajectoryRequest::Request& req, ramp_msgs::TrajectoryRequest::Response& res) {$/;"	f	class:MobileBase	signature:(ramp_msgs::TrajectoryRequest::Request& req, ramp_msgs::TrajectoryRequest::Response& res)
trajectoryRequest	mobile_base.h	/^  bool trajectoryRequest(ramp_msgs::TrajectoryRequest::Request& req,ramp_msgs::TrajectoryRequest::Response& res);$/;"	p	class:MobileBase	access:public	signature:(ramp_msgs::TrajectoryRequest::Request& req,ramp_msgs::TrajectoryRequest::Response& res)
u	main.cpp	/^Utility u;$/;"	v
u	mobile_base.cpp	/^  double u      = reflexBezier_.inputParameters->CurrentPositionVector->VecData[0];$/;"	l
u2	mobile_base.cpp	/^  double u2 = u * u;$/;"	l
u_dot	mobile_base.cpp	/^  double u_dot  = reflexBezier_.inputParameters->CurrentVelocityVector->VecData[0];$/;"	l
u_dot	mobile_base.cpp	/^  double u_dot = CYCLE_TIME_IN_SECONDS;$/;"	l
u_dot_dot	mobile_base.cpp	/^  double u_dot_dot  = reflexBezier_.inputParameters->CurrentAccelerationVector->VecData[0];$/;"	l
u_dot_dot	mobile_base.cpp	/^  double u_dot_dot=0;$/;"	l
utility_	mobile_base.h	/^  Utility utility_;$/;"	m	class:MobileBase	access:private
x	mobile_base.cpp	/^  double x = (1-u)*x0.positions.at(0) + u*x1.positions.at(0);$/;"	l
x	mobile_base.cpp	/^  double x = mu2*p0.positions.at(0) + 2*mu*u*p1.positions.at(0) + u2*p2.positions.at(0);$/;"	l
x1_next	mobile_base.cpp	/^  ramp_msgs::MotionState x1_next;$/;"	l
x1_prev	mobile_base.cpp	/^  ramp_msgs::MotionState x1_prev;$/;"	l
x_diff	mobile_base.cpp	/^  double x_diff = fabs(x1.positions.at(0) - x0.positions.at(0));$/;"	l
x_dot	mobile_base.cpp	/^  double x_dot = ((bc.A*u) + bc.C)*u_dot;$/;"	l
x_dot	mobile_base.cpp	/^  double x_dot, y_dot;$/;"	l
x_dot_dot	mobile_base.cpp	/^  double x_dot_dot = bc.A * u_dot_dot;$/;"	l
y	mobile_base.cpp	/^  double y = (1-u)*x0.positions.at(1) + u*x1.positions.at(1);$/;"	l
y	mobile_base.cpp	/^  double y = mu2*p0.positions.at(1) + 2*mu*u*p1.positions.at(1) + u2*p2.positions.at(1);$/;"	l
y_diff	mobile_base.cpp	/^  double y_diff = fabs(x1.positions.at(1) - x0.positions.at(1));$/;"	l
y_dot	mobile_base.cpp	/^  double x_dot, y_dot;$/;"	l
y_dot	mobile_base.cpp	/^  double y_dot = ((bc.B*u) + bc.D)*u_dot;$/;"	l
y_dot_dot	mobile_base.cpp	/^  double y_dot_dot = bc.B * u_dot_dot;$/;"	l
~MobileBase	mobile_base.cpp	/^MobileBase::~MobileBase() {$/;"	f	class:MobileBase	signature:()
~MobileBase	mobile_base.h	/^  ~MobileBase();$/;"	p	class:MobileBase	access:public	signature:()
